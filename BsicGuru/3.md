Understanding facts and variables notations

Facts are stored in a multi-valued variable with the name ansible_facts, which is organized as a dictionary

To address specific values in this dictionary, two formats can be used:
ansible_facts['default_ipv4']['address']
ansible_facts.default_ipv4.address

Of these two, the first one is preferred

On old versions of ansible, facts were stored as individual variables (injected variables): ansible_default_ipv4 instead of ansible_facts['default_ipv4']

Some modules only support the old wway of referring to facts

vim old_facts.yaml
---
 - hosts: all
   tasks:
   - name: show IP address
     debug:
	   msg: >
	     This hosts uses IP address {{ ansible_default_ipv4.address >>
		 
		 
greater that sign - allows to type a message that's longer than one line 

That's the injected variable cell, ansible 2.5 and before this was common

vim new_facts.yaml
---
 - hosts: all
   tasks:
    - name: show IP address
	  debug:
	    msg: >
		  This host uses IP address {{ansible_facts['default_ipv4']['address'] }}
		  
    - name: show IP address - new and deprecated
	  debug: 
	    msg: This host uses IP address {{ ansible_facts.default_ipv4.address }}
	- name: again - old notation one
	  debug:
	    msg: This host uses {{ ansible_default_ipv4['address'] }}
		
	- name: again - old and so deprecated
	  debug:
	    msg: This host uses {{ ansible_default_ipv4.address }}
		

Troubleshooting slow fact collection

In some conditions fact collection may be very slow

If fact collection is slow because you're working against lots of hosts, you can use a fact cache

If you're experiencing slow fact gathering, ensure that host name resolution is set up on all hosts

Ensure that each managed hosts has an /etc/hosts file that allows for name resolution between all managed hosts

time ansible-playbook.yaml new_facts.yaml

time command - allows you to time how long specific action is taking 

real - real (all) time
user - user time 
sys - system time (kernel time)

Important thing is that a remote host need to be able to resolve the name with the IP address of the control machine

ansible all -m copy -a "src=/etc/hosts dest=/etc/hosts"

Using Multi-valued Variables

Dictionaries versus Arrays

The are 2 ways to store variables with multiple values, the dictionary and the array

Dictionaries and arrays in ansible are based on python dictionaries and arrays

An array (aka list) is an ordered list of values, where each value can be addressed individually
 List = ["one","two","three"]
 print(List[0])

A dictionary (hash) is an unordered collection of values, which is stored as a key-value pair
 Dict = {1:'one',2:'two',3:'three'}
 print(Dict)
 
Notice that a dictionary can be presented in a list


Array is the same as a list
Dictionary is the same as a hash


Understanding Array amnd Dictionary

Multi-valued variables can be used in playbooks

When using a multi-valued variable, it can be written as an array (list), or as a dictionaty (hash)

Each of these has their own specific use cases

 - Dictionares are used in ansible facts
 - arrays are common for multi-valued variables and easily support loops
 - loops are not  supported on dictionaries directly, only indirectly by using the dic2items filter or by using with_dict (deprecated)
 
See ansible doc "Iterating over a dictionary"


Understanding dictionary (hash)

Dictionaries can be written in two ways:

users:
 linda:
  username: linda
  shell: /bin/bash
 lisa:
  username: lisa
  shell: /bin/sh

Or as:

users:
 linda:{ username: 'linda', shell: '/bin/bash' }
 lisa: { username: 'lisa', shell: '/bin/bash' }
 

Using dictionary

To address items in a dictionary, you can use two notations:
 variable_name['key'], as in users['linda']['shell']
 variable_name.key, as in users.linda.shell
 
Dictionaries are used in facts, use arrays in conditionals

Notice that dictionaries can be a part of a list, which is used in ansible facts

Using Array (list)

Arrays provide a list of items, where each item can be addressed separately

users:
 - username: linda
   shell: /bin/bash
 - username: lisa
   shell: /bin/sh
   

You can easily recognize the array because in an array every item starts with a hyphen

Every item starts with a hyphen and the array has different properties for these users

Individual items in the array can be adressed, using the {{ var_name[0] }} notation

where 0 is the array offset and print the first value in the array

Use arrays for looping, not dictionaries

To access all variables, you can use with_items or loop

Recognizing lists and dictionaries

In output like facts, a list is always written between []

Dictionaries are written between { }

Adn if the output is just showing " ", it is a string

Check ansible_mounts in the facts, which actually presents a list of dictionaries

try to gather facts and check where arrays adn where dictionaries and where strings

ansible_facts itself is a dictionary, a dictionary containing dictionaries which may contain arrays

ansible_mounts starting with a square bracket which means that he content really is an array and in the array we have dictionaries so it's an array of dictionaries and that is how we can mix the two of them together

vim vars/users-dictionary
users:
 linda:
  username: linda
  homedir: /home/linda
  shell: /bin/bash
  
 lisa:
  username: lisa
  homedir: /home/lisa
  shell: /bin/bash
  
We can see the dictionary - we recognized it because there are no hyphens

If we define an array, every item in the array starts with a hyphen

vim vars/users-list
users:
 - username: linda
   homedir: /home/linda
   shell: /bin/bash
 - username: anna
   homedir: /home/anna
   shell: /bin/bash
   
vim multi-list.yaml
---
- name: show lists also known as arrays
  hosts: ansible1.example.com
  vars_files:
   - vars/users-list
  tasks:
   - name: print array values
     debug:
	   msg: "User {{ item.username }} has home dir {{ item.homedir}} and shell {{item.shell }}
	 loop: "{{ users }}"
   - name: print the second array value
     debug:
	   msg: the second item is {{ users[1] }}


We are including the variable file and in this variable file we are addresiing the items in the array by looping over users

Loop is something that we can use on an array and loop will work on every single item that is encountered on the array 

Item is the thing that staring with a hyphen

One line for every single item in the array

vim multi-dcitionary.yml
---
- name: show dictionary also known as hash
  hosts: ansible1.example.com
  var_files:
   - vars/users-dictionary
  tasks:
   - name: print dictionary values
     debug:
	   msg: "User {{ users.linda.username }} has home dir {{ users.linda.homedir }} and shell {{ users.linda.shell }}"
	   
There is no way to easily loop over the values in a dictionary

You need to be aware of, use the right approach when encountering the reght variable type

Most inportant the ansible facts by nature is a huge collection of dictionaries and arrays is what you can use to loop over


Dictionaries are honestly not as spectacular but in a dictionary we can address the dictionary value specifically.



######

Understading Magic variables

Magic variables are special reserved system variables 
 - hostvars - prints all the variables assigned to a host
 - groups - is about all hosts groups
 - group_names - prints all names of the host groups
 - inventory_hostname - the host name as defined in inventory
 - inventory_hostname_short - the short alternative
 
This metric variables are reserved and we can not redefine them yourself, they have the highest possible priority

hostvars can be used to address facts or inventory variables from other hosts: {{ hostvars['ansible2']['ansible_facts']['distribution'] }}

groups can be used to list all hosts in an inventory group { % for host in groups['webserver'] %]

group_names has all inventory groups a host is in { % if 'webserver' in group_names % }

inventory_hostname or inventory_hostname_short can be used to address a host as an alternative to ansible_hostname when fact-gathering is disabled


####
Using register

Register is a nice way to automatically define variables based on command result 

register can be used to store the result of a task in a variable

It provides an awesome way to perform specific tasks only upon success or failure of another task

vim register.yaml
---
- name: test register
  hosts: all
  tasks:
   - shell: cat /etc/passwd
     register: passwd_contents
   - debug:
       var: "passwd_contents"
   - debug:
       msg: {{ passwd_contents.rc }}	   
	   msg: {{ passwd_contents['rc'] }}	

Register defines it's variable on every single host, so basically it becomes a property of the host.

We can address all fileds of new variable like

passwd_contents.rc is going to print the return code

rc - result of the command


#### 

Dealing with sensitive data

Vault is the asnible way to store sensitive information 

Some modules require sensitive data to be processed

This may include webkeys, passwords, and more

To process sensitive data in a secure way, ansible vault  can be used

ansible vault is used to encrypt and decrypt files

To manage this process, the ansible-vault command is used

And one the file is encrypted with ansible vault, we need to tell ansible playbook to decrypt it

Demo: using encrypted files

ansible-vault --help

rekey - is what you can use to change the current password on a vault encrypted file

ansible-vault create secret.yml
username: bob
pwhash: password

vim create-user.yml
---
- name: create a user
  hosts: all
  vars_files:
   - secret.yml
  tasks:
   - name: creating user
     user:
	  name: "{{ username }}"
	  password: "{{ pshash }}"
	  
	


ansible-paybook --ask-vault-pass create-users.yml

ansible all -a "tail /etc/shadow"

echo password > vault-pass

ansible-playbook --vault-password-file=vault-pass create-users.yml


####
Lab: making playbooks flexible with variables

create an anventory file that defines a host group webservers ans well as a group dbservers

create the file group_vars/webservers with the following contants
web_package: httpd
web_service: httpd

create a simple playbook that uses the debug module to show the current value of the variables web_package and web_service

vim inventory

[dbservers]
hostname

[webservers]
hostname

mkdir group_vars

vim group_vars/webservers
web_package: httpd
web_service: httpd


It is important  that the name of var file matches tha name that you are using in inventory

vim lab5.yaml
---
- name: lab5
  hosts: webservers
  tasks:
   - debug:
       msg: using {{ web_package }} and {{ web_service }}
	   
##################

Conditionals overview

handlers are tasks that only run if triggered by a task that has changed something

items can be used to iterate over a list

when is used for conditional task execution

blocks can be used to implement if-then-else like statements

register is useful aid to record the result of a task in a variable

fail is a module that is used to perform a specific task on failure


Understanding handlers

a handler is a task that is only executed when triggered by a task that has changed something

handlers are executed after all tasks in a play

if any task fails after the task that has called the handler, handlers are not executed

Use force_handlers to change that behavior

default behavior is ansible happens to be if execution of a specific task, on a specific host is failing then further play execution on that host is aborted

vim handlers.yml
---
- name: set up web server
  hosts: rocky
  force_nadlers: yes | true
  tasks:
   - name: install httpd
     yum:
	  name: httpd
	  state: latest
   - name: copy index.html
     copy:
	  src: /tmp/index.html
	  dest: /var/www/html/index.html
   - name: copy nothing - intended to fail
     copy:
	  src: /tmp/nothing
	  /var/www/html/nothing.html
  handlers:
    - name: restart_web
	  service:
	   name: httpd
	   state: restarted
	   
Handlers  are going to be operational if something has changed.
So if tasks did't change anything, handler will not work

ansible all -m file -a "name=/var/www/html/index.html state=absent"

Force handlers allows you to force the handlers to be started even if any subsequent tasks are failing


###########
Using conditions

when statements are used to run a task conditionally

playbook variables, registered variables, and facts can be used in conditions and make sure that tasks only run if specific conditions are true

For instance, check if a task has run successfully, a certain amount of memery is available, a file exists, etc

Suing facts is very common in when statements

Examples:

ansible_machine == "x86_64"

The fact that the value is between double  quotes makes it ansible will interpret it as a  string

ansible_distribution_major_version == "8"

ansible_memfree_mb == 1024

If we don't see double quotes, so this is interpreted as an integer

With integers we can use grater than and smaller than

ansible_memfree_mb < 256
ansible_memfree_mb > 256
ansible_memfree_mb <= 256
ansible_memfree_mb >= 256

ansible_memfree_mb != 256

my_variable is defined

my_variables is not defined

my_variable - is checking for a boolean value

ansible_distribution in supported_distros

ansible distribution os the injected fact style fact and supported distros is another variable.

vim distro.yml
---
- name: when demo
  hosts: all
  vars:
    supported_distros:
      - Rocky
      - CentOS
      - Fedora
    rhpackage: httpd
    ubupackage: apache2
  tasks:
    - name: install RH family specific packages
      yum:
        name: "{{ rhpackage }}"
        state: present
      when: ansible_distribution in supported_distros 
    - name: install Ubuntu package
      apt:
        name: "{{ ubupackage }}"
        state: present
      when: ansible_distribution == "Ubuntu"
	  


vim quicktest.yml

---
- name: test command result
  hosts: all
  tasks:
    - name: check a fact
      debug: 
        msg: echo today is 25
      when: '"25" in ansible_date_time.day'
	  
	  
Ubnderstanding register

Register is particularly useful in combination with when statements

Register is used to store the output of a command, and adddress it as a variable

And next we can use the result of the command in a conditional or in a loop


vim command-output-test.yml

---
- name: test command output
  hosts: ansible1.example.com
  tasks:
    - name: test for VG existence
      command: vgs centos
      register: vgout
      ignore_errors: True
    - name: show variable value
      debug:
        var: vgout
    - name: print message
      debug:
        msg: vg does not exist
      when: "'not found' in vgout.stderr"
	  
ignore_errors can be set in a play header, can also be set in a task header. In this example it has a task scope. So only for this task, if it has an error, we continue. If all the tasks have an error, then the playbook execution will stop and produce a normal error behavior

In a when statement, we do not have to use the curly braces to refer to the variables.

ansible hostname -a "vgs"


vim register_command.yml
---
- name: test register
  hosts: all
  vars_prompt:
    - name: username
      prompt: which user are you looking for
	  private: no
  tasks:
    - shell: cat /etc/passwd
      register: passwd_contents
    - debug:
        var: passwd_contents
    - debug: 
        msg: echo "passwd contains user {{ username }}"
      when: passwd_contents.stdout.find(username) != -1



private: no 
By default vars_prompt will not show the results of what the user is typing

find - this is python command that is used on the standard out on the register variable

() - python way to refer to a variable

-1 if this python find function will find the username it will give a byte offset like 386 if the user was find starting at byte 386. And if user was not found, then it will give a minus one. 



###################

Understanding ansible vlocks

A block is a logical group of tasks

Blocks are used to control how tasks are executed

One block can, for instance, be enabled using a single when

Blocks can also be used in error condition handling

 use block to define the main tasks to run
 use rescue to define tasks that run if tasks defined in the block fail
 use always to define tasks that will run, regardless the success or failure of the block and resccue tasks
 
blocks can be used lije if then else statement

Items can not be used on blocks

vim blocks.yml
- name: simple block example
  hosts: all
  tasks:
    - name: setting up http
      block:
      - name: installing http
        yum:
          name: httpd
          state: present
      - name: restart httpd
        service:
          name: httpd
          state: started
      when: ansible_distribution == "Rocky"


It is good practice when working with ansible, test conditions in different way (talking about variables, conditions etc)


vim blocks2.yml
---
- name: using blocks
  hosts: all
  tasks:
    - name: intended to be successful
      block:
        - name: remove a file
          command:
            cmd: /usr/bin/rm /var/www/html/index.html
		  or
          file:
            path: /var/www/html/index.html
            state: absent			
      rescue:
        - name: create a file
          command:
            cmd: /usr/bin/touch /tmp/rescuefile
		  or
		  file:
		    path: /tmp/rescuefile
			state: touch
      always:
        - name: always write a message to logs
          command:
            cmd: /usr/bin/logger hello
			
Rescue will earn tasks if tasks that are defined in the block are failing

#################

loop.md

Understanding loop



Ansible offers different solutions to implement iterations

Items are easy to use
 - Define a list of items
 - In the task, use loop (previously: with_items) to process the items
 
 
Example:
- name: remove files
  file:
    name: "{{ item }}"
	state: absent
  loop:
   - file1
   - file2
   

Using variables to define a loop
 
Do not forget about separating site specific data from code

The list that loop is using can be defined by a variable

vars:
  my_services:
   - httpd
   - vsftpd
tasks:
 - name: start some services
   service:
     name: "{{ item }}"
	 state: started
   loop: "{{ my_services }}"
   
Using Arrays in Loops

Each item in a loop can be array with multiple keys in each array item

- name: create users using a loop\
  hosts: all
  tasks:
  - name: create users
    user:
	  name: "{{ item.name }}"
	  state: present
	  groups: "{{ item.groups }}"
  loop:
   - name: anna
     groups: wheel
   - name: linda
     groups: users
	 
	 
Understanding loops vs items

The loop keyword is the current keyword

In previous versions of ansible, the with_* keyword was used for the same purpose

The loop syntax is preferred, but with_X is still supported as well

From ansible 2.5 developers introduced loop, and with_* was deprected. But it happens to be that some things are better done using with. And that is why the current statement has changed. Loop is preferred but in some cases it's okay to use with whatever.

with_items: equivalent to the loop keyword
with_file: the item contains a file, which contents is used to loop through
with_sequence: generates a list of values based on a numeric sequence

Most of the with_X statements can now be replaced with filters

vim loopservices.yml

- name: start some services
  hosts: ansible2.example.com
  vars:
    my_services:
      - crond
      - sshd
  tasks:
    - name: start some services
      service:
        name: "{{ item }}"
        state: started
      loop: "{{ my_services }}"
	  
vim loopusers.yml
---
- name: create users using a loop
  hosts: all
  tasks: 
  - name: create users 
    user: 
      name: "{{ item.name }}"
      state: present
      groups: "{{ item.groups }}"
    loop:
      - name: anna
        groups: wheel
      - name: linda
        groups: users
      - name: bob
        groups: users
		
vim install _and_run.yml
---
- name: install and run software
  hosts: ansible2
  tasks:
  - name: install packages
    package: 
	  name:
	   - vsftpd
	   - nmap
	   - httpd
	  state: latest
  - name: run them
    service:
      name: "{{ item }}"	
	  state: started
	loop:
	 - vsftpd
	 - httpd
	 
The point is, that for every single item that we are specifying, it is running the task again. If we have 100 items then we run your task a hungred times.

Limited number of modules is ansible allow us to specify lists in the name of the module, which means that you run the module once and while running it once it is installing all of them.

we can check it by:
ansible-doc yum

find - name and find type, it will be list

ansible-doc package
This doc don't provide info about list support.


If you have a module that supports a list in its name, always use it.

if we cannot find it in a documentation use common sense, common sense as in


#####

Managing failure with the fail module

Understanding failure handling

Ansible looks at the exit status of a task to determine whether it has failed

This may lead to failures occuring when nothing really is going wrong

When any taks fails, ansible aborts the rest of the play on that host and continues with the next host

different solutions can be used to change that behavior

use ignore_errors in a task to ignore failures
It can be used in a task or in a play header

Use force_handlers to forcee a handler that has been triggered to run, even if (another) task fails

Defining Failure States

As ansible only looks at the exit status of a failed task, it may think a task was successful where that is not the case 

To be more specific, use failed_when to specify what to look for in command output to recognize a failure

Using the fail module

The failed_when keyword can be used in a task to identify when a task has failed

The fail module can be used to print a message that informs why a task has failed

To use failed_when of fail, the result of the command must be registered, and the registered variable output must be analyzed

When using the fail module, the failing task must have ignore_errors set to yes. Because the  essence of the fail module is that you want to do something if a failure occurs. And if you want to do something after the failure, well, it's mandatory to use ignore errors, because otherwise play execution will be aborted on that specific host. 



vim failure.yml

---
- name: demonstrating failed_when
  hosts: all
  tasks: 
    - name: run a script
      command: echo hello world
      ignore_errors: yes
      register: command_result
      failed_when: "'world' in command_result.stdout"
    - name: see if we get here
      debug:
        msg: hello
		
Anytime you use register, register creates a variable name.stdout with the result of the actual command


vim failure2.yml
---
- name: show the fail module
  hosts: all
  tasks:
  - name: do somthing impossible
    lvol:
      lv: lvnothing
      vg: vgnothing
      size: 1G
    register: command_result
    ignore_errors: yes
  - name: show command_result errors
    debug:
      var: command_result.err
  - name: print nice error message after failure
    fail:
      msg: volume group doesnt exist
    when: "'not found' in command_result.err"


###
Using the assert module

The assert module can be used to show a message on success and on failure

It's a bit like the fail module, but with more advanced options

vim assertsize-wrong.yml

---
- hosts: localhost
  vars_prompt:
  - name: filesize
    prompt: "specify a file size in megabytes"
	private: no
  tasks:
  - name: check if file size is valid
    assert:
      that:
      - filesize <= 100
      - filesize >= 1
      fail_msg: "file size must be between 0 and 100"
      success_msg: "file size is good, let\'s continue"
  - name: create a file
    command: dd if=/dev/zero of=/bigfile bs=1 count={{ filesize }} 
	
If we enter a value using vars prompt, we get a string.
If we want to do greater than smaller than operations on a variable, it needs to be an integer

vim assertsize.yml
---
- hosts: localhost
  vars_prompt:
  - name: filesize
    prompt: "specify a file size in megabytes"
	private: no
  tasks:
  - name: check if file size is valid
    assert:
      that:
      - "{{ (filesize | int) <= 100 }}"
      - "{{ (filesize | int) >= 1 }}"
      fail_msg: "file size must be between 0 and 100"
      success_msg: "file size is good, let\'s continue"
  - name: create a file
    command: dd if=/dev/zero of=/bigfile bs=1 count={{ filesize }} 
	
This is example of passing through the integer filter.
This filter does not changing the contents of variable, it's just changing the interpretation

Assert, a little bit like block and rescue and always - is just another way of implementing something that looks like an if the else statement


####

Using when to make the command module idempotent

Idempotency ensures that running a playbook always gives the same result, no matter the current state of the managed asset. Command, shell and raw module are not idempotent by nature. However if you're using register in a smart way, you can use even these modules in an idempotent way.

Create a playbook that creates a user using the command module in such a way that the playbook is idempotent.


If number is not between double quotes means that this is integer

- name: creates user {{ user }}
  vars:
    user: linda
  hosts: ansible2
  tasks:
  - name: checkuser
    command: id {{ user }}
	register: iduser
  - name: 
    debug:
	  var: iduser
  - name: beforecheck
    fail:
	  msg: user already exists
	when: iduser.rc == 0
  - name: create user {{ user }}
    command: userdd {{ user }}
	
- name: continuing
  hosts: ansible2
  tasks:
   - debug:
       msg: we made it =)
	   
#####
Manipulating Files

ansible.builtin.copy is used to copy files from the control host to a managed host

ansible.posix.synchronize synchronizes files content and is more efficient

The synchronized module has one requirement - it needs rsync to be installed on managed host

ansible.builtin.fetch will fetch a file from a managed host to the control host


Using copy:
Use ansible.builtin.copy as an ansible alternative to linux copy

It can copy over individual files, as well as directories

use contents to copy a line of text into a new destination file

Using synchronize

ansible.posix.synchronize is using the rsync command to synchronize files from the control host to managed hosts

ansible.posix.synchronize is more efficient for copying large amounts of files than ansible.builtin.copy, because it is capable of doing a DeltaSync. So we will only synchronize things that really needs to be changed

It does require the rsync software to be installed on all hosts involved

Use delegate_to to change the source host to a host different than localhost

Using fetch

ansible.builtin.fetch can be used to fetch a file from a managed machine and store it on the control host

It will store files by appending hostname /path/to/file to the fetched file

Use the flat option to override this behavior and store just the filename



Changing file contents

ansible.builtin.copy can be used to create files with simple contents
ansible.builtin.replace is used for simple replacements
ansible.builtin.lineinfile can be used to manipulate single lines in  a text file
ansible.builtin.blockinfile is useful for manipulating complete blocks of text

Using copy and replace
ansible.builtin.copy and ansible.builtin.replace can be used for simple operations

Use the content argument to the copy module to copy a string into a destination file
  ansible all -m copy "content=hello dest=/tmp/hellofile"
  
The replace module allows you to replace file contents based on regular expression

 use regexp to identify the regular expression you want to replace
 use replace to specify the replacement text
 Omit the replace argument if you just want to remove text
 

Using lineinfile and blockinfile

Use lineinfile to add a single line to a file

Use blockinfile to add multiple lines to a file

vim copy.yml

---
- name: file copy modules
  hosts: all
  tasks:
  - name: copy file demo
    copy:
      src: /etc/hosts
      dest: /tmp/
  - name: add some lines to /tmp/hosts
    blockinfile:
      path: /tmp/hosts
      block: | 
        192.168.4.110 host1.example.com
        192.168.4.120 host2.example.com
      state: present
  - name: verify file checksum
    stat:
      path: /tmp/hosts
      checksum_algorithm: md5
    register: result
  - debug:
      msg: "The checksum of /tmp/hosts is {{ result.stat.checksum }}"
  - name: fetch a file
    fetch:
      src: /tmp/hosts
      dest: /tmp/
	  
Pipe behind the name of the module, which is making sure that the next couple of lines iw written to the configuration file with this specific layout. Text is wrapped over multiple lines.

The stat module is mostly used in combination with the register



##########

Using the find module

The find module is used to perform operations on multiple files

It is similar to the Linux find command

Use it with regular expressions, or in combination with lineinfile to perform modifications on multiple files that match a certain criterium

When using register together with find, you can easily build a playbook to change files regardless of their exact location

vim changeconfig.yaml

---
- name: find config
  hosts: localhost
  become: true
  tasks:
  - name: find ansible.cfg files
    find:
      paths: /home/ansible/rhce8-live
      patterns: 'ansible.cfg' 
      recurse: yes
    register: output
  - debug:
      var: item.path
    with_items: "{{ output.files }}"
  - blockinfile:
      path: "{{ item.path }}"
      insertafter: "defaults"
      marker: "##<!-- {mark} ANSIBLE MANAGED BLOCK -->##"
      block: |
        fact_caching = redis
        fact_caching_timeout = 3600
        fact_caching_connection = localhost:6379:0
    with_items: "{{ output.files }}"


If we want to set up the fact cache, we need to change ansible.cfg

The thing is that find will generate a list of files. This list of files is written to the files variable within the output variable.


####

Using templates

A meplate is a sample configuration file that is combined with environment variables to produce sire specific configuration files

Templates are based on the Jinja2 templating language

In advance templates, conditional structures as well as loop structures can be used

By defaults templates should be in template directory

ansible likes dedicated directories


template - some layout which we should combine with specific values set in variables

vim templates/motd.j2

Welcome to {{ ansible_facts['fqdn'] }}
This system is running {{ ansible_facts['distribution'] }} version {{ ansible_facts['distribution_version'] }}

vim motd.yaml
---
- name: install motd
  hosts: all
  tasks:
  - name: install motd
    template:
      src: motd.j2
      dest: /etc/motd
      owner: root
      group: root
      mode: 0644
	  
When we are using ansible mode, there are two options.
Either we put our permission mode between single quotes and then we can use three digits for user group and other permissions.

Four digit mode in which we need a leading zero/
If we don't use single quotes, neither use 4 digits and use three digits, then the six is interpreted as special permissions and we have wrong permissions.

This applies to anywhere where we are going to use a mode parameter in ansible.

ansible all -a "cat /etc/motd"

Check in documentation information about conditional structures as well as loop structures.
Find frequently asked questions
and there how do i loop over a list of hosts inside a template

ansible hostname -m setup | less

vim templates/hosts.j2
{% for host in groups['all'] %}
  {{ hostvars[host]['ansible_default_ipv4']['address'] }}   {{ hostvars[host]['ansible_fqdn'] }} {{ hostvars[host]['ansible_hostname'] }} 
{% endfor %}



Notece that hostvars[host] is not something that needs to be interpreted as a real variable. It is a hostvars variable and that is why the host does not get single quotes. And the single quotes are aroung the fact.


vim hosts.yaml
---
- name: install hosts
  hosts: all
  tasks:
  - name: install hosts
    template:
      src: hosts.j2
      dest: /tmp/newhosts
      owner: root
      group: root
      mode: 0644
	  
ansible all -a "cat /tmp/newhosts"



###

Lab working with files

write a playbook that is doing the following

Installs vsftpd on all managed hosts

copies the file /etc/vsftpd/vsftpd.conf from one of the managed hosts to the control host

converts that file into a template, adding one line to the end of the file
# written on {{ ansible_hostname }}

uses the template to create a new version of the configuration file on the managed hosts

ensures that vsftpd is started, enabled and accessible through the firewall

dash - list
no dash - properties

When do we need a dash to indicate a list and when don't we need it? - we don't need to put arguments to a module

ansible-doc -s ??? check meaning

vim lab7.yml
---
 - name: copy conf to local
   hosts: all
   tasks:
   - name: install vsftpd
	 dnf:
	   name: vfsftpd
	   state: latest
   - name: fetch the file
	 fetch:
	   src: /etc/vsftpd/vsftpd.conf
	   flat: test
	   dest: /tmp/vsftpd.j2
		 
 - name: modify file on control
   hosts: localhost
   become: yes
   tasks:
    - name: add line to file
	  lineinfile:
	    name: /tmp/vsftpd.j2
		line: '# write on {{ ansible_hostname }}'
		
 - name: finish it
   hosts: all
   tasks:
    - name: use template
	  template:
	    src: /tmp/vsftpd.j2
		dest: /etc/vsftpd/vsftpd.conf
 - name: start it
   service:
     name: vsftpd
	 state: started
	 enabled: yes
 - name: open firewall
   firewalld:
     service: ftp
	 immediate: yes
	 permanent: yes
	 state: enabled
	 


ansible ansible1 -a "systemctl status vsftpd"

I like to improvise =)
Let's move on

#####################

Understading collections

Collections since ansible 2.10 and in preview 2.9 are a new way to bundle ansible contanets to make it more manageable

Collections can have different sources, including ansible community and Red Hat partners

So by using ansible collections we get better quality control

A role is basically a collection of a couple of tasks that have configured to do something common

Collections may contain following items:
 - modules that provide the ansible core functionality
 - roles that can be included in playbooks for common task execution
 - plugins that extend the pyhthon code on the ansible control host
 




Understanding collection naming

Collections have a Fully Qualified Collection Name (FQCN), such as ansible.netcommon

Within this FQCN, plugins, modules etc are addressed with their own name, such as ansible.netcommon.cli_command

Before collections, you would address just a module name such as user, now we address this module as ansible.builtin.user

Start with a collections setting in the play header and list all collections you-re going to use


vim enforce-selinux.yml
---
- name: set SELinux to enforcing
  hosts: localhost
  gather_facts: no
  become: yes
  tasks:
  - name: set SELinux to enforcing
    ansible.posix.selinux:
      policy: targeted
      state: enforcing
	  

vim enforce-selinux-simplified.yml
---
- name: set SELinux to enforcing
  hosts: localhost
  gather_facts: no
  become: yes
  collections:
  - ansible.posix
  tasks:
  - name: set SELinux to enforcing
    selinux:
      policy: targeted
      state: enforcing



##########
Understanding roles

Roles are community-provided resources that make working with ansible easier

They provide standardized solutions for common tasks

Instead of finding out yourself, we can use community-provided roles in out playbooks

Just add the site-specific configuration using variables in the playbook, and run everything else from the roles

Custom roles can also be provided

Understanding task execution order

Tasks in roles are normally executed before other tasks in the playbook

Use pre_tasks to execute tasks before the role

Handlers that are triggered by pre_tasks are also executed before the roles


vim nginx-role.yml
---
- name: use galaxy nginx role
  hosts: ansible2.example.com
  user: ansible
  become: true

  roles:
    - role: geerlingguy.nginx
	
ansible-galaxy --help

ansible-galaxy role install geerlingguy.nginx

ansible playbook nginx-role.yml


#################

Understanding galaxy

galaxy.ansible.com is the community website that provides access to roles and collections

while using galaxy,  you can find the required commands to install roles and collections easily

ansible-galaxy in the command line interface that allows you to work with galaxy

use ansible-galaxy collection to manage collections

use ansible-galaxy role to manage roles

geerlingguy - one of the main pepople in the ansible community


ansible-galaxy role -h

ansible-galaxy role list

If we use ansible-galaxy role install, by default it ends in /home/ansible/.ansible/roles

cd /home/ansible/.ansible/roles

tree command

default and vars - these are about variables
Default is our default variables, they can be overwritten in vars in many cases operating system, specific variables.

tasks - every role has tasks, the main playbook in any directory has the name main.
main.yml - containing the main task

#################

Using collections in playbooks

In the play header, the collections keyword can be used

It takes a list of collections as its argument

After using the collection keyword, the collection itself can be addressed the old way: selinux instead of ansible.posix.selinux

Using collections

In ansible 2.9, collections are not a default part of ansible

To use them, they need to be installed from ansible galaxy

To install multiple collections. consider using a requirements file


(ansible 2.9 and below)
ansible-galaxy collection install -r requirements.yml

In ansible .20 adn later, collections are installed by default


Getting collection information

Ansiblw 2.10 and later contain better collection integration
Collection names can easily be found using ansible-doc: ansible-doc -l | grep aws

Ansible 2.9 shows opnly collections that have been installed

Collections are not listed with ansible-doc -l
Collection documentation is available while addressing collection components directly
Finding collection names only goes through the installed files

Listing collections

Use ansible-galaxy collection list (2.10 and later) to show a complete list of collections

To verify the contents of the collection, access it's physical location and investigate the directory structure

Demo: using ansible collections

ansible-galaxy collection install ansible.posix

tree ~/.ansible/collections/ansible_collections/ansible/posix

ansible-doc ansible.posix.selinux;
ansible-doc ansible.posix.acl


download tarball with ansible.posix


 
ls -l ~/.ansible/collections/ansible_collections

cp tarball there 

tar -xvf 

mkdir -p ansible/posix

mv * ansible/posix

use tree to view (this is all about 2.9 and below)

Modules happen to be plugins as well

ansible-doc ansible.posix



####

Automation hub is a red hat subscription platform and it's used to work with collections as well

Using collection sources

Community collections are provided through ansible galaxy

Subscription-only collections are through
https://cloud.redhat.com/ansible/automation-hub

Automation hub contains collections from red hat, but also partnet collections

Go to https://cloud.redhat.com/ansible/automation-hub/token to get an authentication token that is needed for using collections; this token needs to be stored in the ansible.cfg

Using collections from automation hub

Get a token https://cloud.redhat.com/ansible/automation-hub/token

select automation hub - connect to hub and copy the toekn

Edit ansible.cfg to include the galaxy server and token

[galaxy_server.automation.hub]
url=https://cloud.redhat.com/api/automation-hub/
auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token
token=xxxxxx

[galaxy_server.release_galaxy]
url=https://galaxy.ansible.com/
token=xxxxx


Using  collections from automation hub

To install collections from automation hub, create a requirements.yml file

collections:
- name: f5networks.f5_modules
  source: https://cloud.redhat.com/api/automation-hub/

Install using the requirements file

ansible-galaxy collection install -r collections/requirements.yml

Use ansible-galaxy collections -l to show a list of currently installed collections

  


vim requirements.yml

collections:
  - name: f5networks.f5_modules
    source: https://cloud.redhat.com/api/automation-hub/
  - name: ansible.netcommon
    source: https://galaxy.ansible.com
  - name: ciscosmb
    source: https://galaxy.ansible.com
	
	
	
#####

Creating your own roles

ansible-galaxy role init RoleName

everything that's not required in role - should be deleted

The roles are supposed to be in the roles directory

vim pretasks.yml
---
- name: run a task before a role
  hosts: all
  pre_tasks:
    - name: update yum cache
      yum:
        update_cache: yes
  roles:
    - motd



### Nginx role - install nginx, make sure that before using the role, th following is done:
if installed and running, apache is removed
Perform an update of all packages

After running the role, remove the yum package cache

Solution:

Always go for the most specific solution

ansible-galaxy role list

sudo -i

Quoting issue 
Often in ansible can be a quoting issue

ansible-playbook --help

ansible-playbook lab8.yaml --list-tasks

ansible-playbook lab8.yaml --start-at-task file


vim lab8.yml
---
- name: install nginx
  hosts: all
  pre_tasks:
   - block:
     - name: remove apache
	   service:
	     name: httpd
		 state: stopped
		 enabled: no
     - yum:
	     name: httpd:
		 state: absent
	 - name: perform package update
	   yum:
	     name: '*'
		 state: latest
     when: ansible_facts['os_family'] == 'RedHat' or ansible_facts['os_family'] == 'Rocky'
	 
  roles:
   - geerlingguy.nginx
   
  post_tasks:
   - file:
       path: /var/cache/dnf
	   state: absent


########################

Using includes and imports

First we need to understand why

If playbooks grow larger, it is common to use modularity by using includes and imports

Includes and imports can happen for roles, plays as well as tasks

An include is a dynamic process; Ansible processes the contents of the included files at the moment that this include is reached

An import is a static process; Ansible preprocesses the imported file contents before the actual play is started

The use case for an import is modularity in development

The use case for an include in conditionality. We only want to run it if a specific condition is true

vim includes.yml
---
- name: setup apache
  hosts: all
  tasks:
    - name: setup apache task
      import_tasks: install-and-setup.yml
      vars:
        package: httpd
        service: httpd


vim install-and-setup.yml
---
  - name: install the {{ package }} package
    yum:
      name: "{{ package }}"
      state: latest
  - name: start the {{ service }} service
    service:
      name: "{{ service }}"
      enabled: true
      state: started
	  
import - porpuse is in modularity

vim include.yml
---
 - name: setup a service
   hosts: ansible2
   tasks:
   - name: include the services task file
     include_tasks: tasks/service.yml
	 vars:
	   package: httpd
	   service: httpd
	 when: ansible_facts['os_family'] == 'RedHat'
   - name: include the firewall file
     import_tasks: tasks/firewall.yml
	 vars:
	   firewall_package: firewalld
	   firewall_service: firewalld
	   firewall_rules:
	    - http
		- https



#####

Security in ansible is all about securing connections

Commonly used bur insecure
 -  passphrase-less SSH keys to connect to remote hosts
 -  become = true as a standard setting
 - passwordless privilege escalation
 
More secure but not convenient
 - b -K when needed
 -k instead of SSH keys
 
Making Secure Connections

Do not configure passwordless solutions as a standard!

Securing SSH connections
 - use ssh-keygen to generate as ssh key that is protected with a password
 - use eval ssh-agent $SHELL to start the SSH agent after login
 - use ssh-add ~/.ssh/id_rsa to add your identity to the agent
 - verify using ssh-add -l
 
Consider automating by putting all in ~/bash_profile

You will be prompted for the key password at first use

Next, the password is cached for the remaining duration of your session

if [ -z "$SSH_AUTH_SOCK"]; then
	eval `ssh-agent -s`
	ssh-add
fi


Securing sudo access

Do not use the NOPASSWD option in /etc/sudoers

Instead, increase the timestamp option in /etc/sudoers to decrease the frequence that you will have to enter a password

 - Defaults timestamp_type=global,timestamp_timeout=60
 - timestamp_global keeps an authentification token for passwordless privilege escalation, no matter which terminal a user is coming from
 - timestamp_timeout=60 keeps the token for 60 minutes
 
These options are needed on ALL managed servers
 - consider using line_in_file to get them there
 
On first contact, use -K to prompt for privilege escalation password

In all subsequent commands, omit the -K option until you see an error

After token expiration, use -K again to refresh the token

Demo: securing ansible management

On control, use ssh-keygen and set a password for the ansible user
eval ssh-agent /bin/bash

ssh-add ~/.ssh/id_rsa

Use ssh-copy-id to copy the new public key to managed hosts

Create a playbook that uses lineinfile to replace the default section in /etc/sudoers on all managed hosts. Hints:
regexp: '^Defaults'
line: 'Defaults timestamp_type=global,timestamp_timeout=60'
validate: /usr/bin/visudo -cf %s

Run the playbook with the -k -K options

Use ansible all -a 'ls /root' -b -K and enter the sudo password when prompted

Run again: ansible all -a 'ls /root' -b without any futher options

vim makemesecure.yml
---
- name: make me secure
  hosts: all
  tasks: 
   - lineinfile:
       name: /etc/sudoers
	   regexp: '^Defaults'
	   line: 'Defaults timestamp_type=global,timestamp_timeout=60'
	   validate: /usr/bin/visudo -cf %s
	   
	   



ansible-playbook makemesecure.yml -K -b

ansible all -a 'ls /root' -b -K

ansible all -a 'ls /root' -b

Nice mix between convenient and secure



##############

Understanding tags

example in kubernetes playbook

A tag is a label that can be used in a playbook to identify specific playbook elements

Using tags allows you to run specific parts of the playbook only

Tags are useful in playbook development to skip parts that have proved to be working all right

ansible-playbook --help

ansible-playbook PlayBookName.yml --list-tags

ansible-playbook PlayBookName.yml --skip-tags

ansible-playbook PlayBookName.yml -t TagsName

ansible-playbook PlayBookName.yml --tags TagsName -e kubehost=localhost

ansible-playbook PlayBookName.yml --start-at-task TaskName



######################

Understanding delegation

Delegation is used to run tasks on another host

Use  delegate_to as a task property to run that task on a different host

It allows you to run an individual task on a different host, withoyt any need to start a new play that addresses these hosts specifically


vim delegation.yaml
---
- name: install start and enable httpd
  gather_facts: false
  hosts: rocky
  tasks:
  - name: install package
    package:
      name: httpd
      state: latest
  - name: start and enable service
    service:
      name: httpd
      state: started
      enabled: yes
  - name: test httpd access
    uri:
      url: http://rocky
    delegate_to: localhost
	
Understanding delegation requirements

Delegetion host need to meet the same requirements as regular control hosts

 - pythin is installed
 - ssh access to managed hosts in enabled
 - host name to ip address resolviing works

The delegate_to host must exist in inventory

 
	
Using delegation to copy  files between hosts - 

vim copy-files.yaml
- name: copy files between hosts
  hosts: rocky
  tasks:
  - name: copy file from ubuntu to rocky
    synchronize:
#   copy:	
      src: /etc/hosts
      dest: /tmp/hosts
      mode: push  # comment if copy
    delegate_to: ubuntu
  - name: check file
    stat:
      path: /tmp/hosts
    register: stafile
  - debug:
      var: stafile

ansible-plaubook -vvv copy-files.yaml

synchronioze requires rsync to be present


#####
Understanding parallelism

The first task in a play is executed on all managed hosts before moving over to the next task

By default, this happens on 5 hosts simultaneously

This is because task execution creates workload, as well as network load

If the ocntrol host as well as the network can handle it, you can increase the number of concurrent tasks

Use forks=nn of -f nn

Be carefull increasing this parameter if processing is happening on the control node

Consider using a callback plugin to measure the impact of increasing the number of forks

##################

Copying files

Th copy module can take a long time when dealing with large amounts of files

Consider using the synchronize module, is uses rsync in the background which is more efficient

For synchronize to work, ensure thar rsync is installed on the managed nodes

vim synchronize.yaml
---
- name: copy many files
  hosts: all
  become: true
  gather_facts: false
  tasks:
  - name: update web document root
    synchronize:
      src: webfiles/
      dest: /var/www/html
	  
###############
Optimizing ssh

ansible uses ssh to manage hosts

establishing a new ssh session takes a lot of time 

to make ssh connection more efficient, three ssh features can be used

 - ContolMaster allows multiple simultaneous ssh sessions with a remote host using one network connection
 
 ControlPersist keeps a connaction opne for xx seconds
 
 pipelining allows more commands to use a simultaneous ssh connection
 
 The idea here is to optimize ssh in such a way that you don't need to open a new connection for every single activity that is going to happen.
 
 use na ssh_connction section in ansible config file to specify how to use these options
 
[ssh_connection]
ssh_args = -o ControlMaster=auto -o ControlPersist=120s 
pipelining = true


Configuring sudo for pipelining

When pipelining is enabled, the requiretty sudo option must be disabled

requiretty is a sudo security option. that prevents sudo commands that are not started from a TTY

To verify this option is disabled, use visudo and look for the following
Defaults !requiretty

vim ansible.cfg


vim tunesudo.yml
---
- name: optimize sudo for ssh
  hosts: all
  tasks:
   - lineinfile:
       path: /etc/sudoers
       line: 'Defaults !requiretty'
	   validate: /usr/sbin/visudo -cf %s

time ansible-playbook tunesudo.yml

troubleshooting slow work

use time 

analyze with -vvv 

disable gather facts if possible

create host resolving mathches on managed hosts 

Linux tweak

Host name resolution does play a role



#########
mkdir security

vim secureme.yml 
---
 - name: secure sudo
   hosts: all
   tasks: 
    - name: remote insecure /etc/sudoers.d/ansible file
	  file:
	    name: /etc/sudoers.d/ansible
		state: absent
	- name: create new and secure /etc/sudoers.d/ansible file
	  copy:
	    content: 'ansible ALL=(ALL) ALL'
		dest: /etc/sudoers.d/ansible
	- name: tuning /etc/sduoers.d
	  lineinfile:
	    line: 'Defaults timestamp_type=global,timestamp_timeout=120,!requiretty'
		name: /etc/sudoers
		validate: /usr/sbin/visudoo -cf %s
		
##################
Understanding filters

A filter is a lookup plugin that allows you to manipulate data
It's an actual piece of code that you are going to add to your ansible software

Many filters are available in ansible

apart from that, jinja2 filters can be used in ansible

filters process the value of a variable on the control host before further using it in the playbook

while using filters, it is important to know which vaiable type you re dealing with

Understanding variable types

String: sequence of characters - the default variable type in ansible. If we do not use the double quotes with a string in vars definitions, it will be string anyway

Numbers: numeric value, treated as integer or float. When placing a number in quotes it is treated as a string

Booleans: true/false values (yes/no, y/n, on/off also supported)

Dates: calendar dates

Null: undefined variable type

List of arrays: a sorted collection of values

Dictionary or Hash: a collection of key/value pairs


Recognizing variable types

In the output of, for instance, fact gathering, different variable types can be recognized by the way in which they are written

String: a value between quotes

Numbers: a value that is not between quotes

Booleans: set in inventory and ansible.cfg

dates: "2021-12-30"

Null: undefined variable type - only occurs on undefined variables



vim vartypetest.yaml
---
- name: test variable types
  hosts: localhost
  become: no
  vars:
  - car: mercedes
  - number: 10
  - sunny: True
  - rainy: true
  tasks:
  - name: testing string
    debug:
      msg: car is a string
    when: car == "mercedes"
  - name: testing integer
    debug:
      msg: number is an integer
    when: number == 10
  - name: testing boolean
    debug:
      msg: sunny is a boolean
    when: sunny
  - name: testng boolean case
    assert:
      that: rainy
      success_msg: rainy is a boolean
      fail_msg: rainy is not a boolean
	  
	  
List or an array is a sorted collection of values

List - use notation, it's between square brackets

List of Arrays: a sorted collection of values

"ansible_system_capabilities": [
	"cap_chown",
	"cap_kill"
],

The square brackets is what makes it an array

Dictionary - is a key/value pair

The dictionary is written between braces

We can have combitaion of list and dcitionary - like list of dictionaries (eg ansible mounts is the list of dictionaries)

Dictionary or Hash: multiple values, written between braces:
"ansible_selinux":{
  "config_mode":"enforcing",
  "type":"targeted"
},

######################

Processing variables with filters

Filters allow variables to be processed before using them in ansible

Filters do not change the value of a variable, they just change how the variable is being used

Use {{ varname | filter }} to identify the filter to be used

vim int-filter.yaml
---
- hosts: localhost
  vars_prompt:
  - name: filesize
    prompt: "specify a file size in megabytes"
  tasks:
  - name: check if file size is valid
    assert:
      that:
      - "{{ (filesize | int) <= 100 }}"
      - "{{ (filesize | int) >= 1 }}"
      fail_msg: "file size must be between 0 and 100"
      success_msg: "file size is good, let\'s continue"
  - name: create a file
    command: dd if=/dev/zero of=/bigfile bs=1 count={{ filesize }} 
	
vim storage-filter.yaml
---
- name: set up hosts that have an sdb device
  hosts: all
  tasks:
  - name: getting out with a nice failure message if there is no second disk
    fail:
      msg: there is no second disk
    when: ansible_facts['devices']['sdb'] is not defined
  - name: create a partition
    parted:
      device: /dev/sdb
      number: 1
      state: present
  - name: create a volume group
    lvg:
      pvs: /dev/sdb1
      vg: vgfiles
  - name: run the setup module so that we can use updated facts
    setup:
  - name: get vg size and convert to integer in new variable
    set_fact:
      vgsize: "{{ ansible_facts['lvm']['vgs']['vgfiles']['size_g'] | int }}"
  - name: show vgsize value
    debug:
      var: "{{ vgsize }}"
  - name: create an LVM on big volume groups
    lvol:
      vg: vgfiles
      lv: lvfiles
      size: 6g
    when: vgsize | int > 5
  - name: create an LVM on small volume groups
    lvol:
      vg: vgfiles
      lv: lvfiles
      size: 3g
    when: vgsize | int <= 5
  - name: formatting the XFS filesystem
    filesystem:
      dev: /dev/vgfiles/lvfiles
      fstype: xfs
  - name: mounting /dev/vgfile/lvfiles
    mount:
      path: /files
      state: mounted
      src: /dev/vgfiles/lvfiles
      fstype: xfs
	  
Default interpretation of prompt variable is string

  
Exploring Common filters

mandatory fails a play if a variable doen not have a value 
{{ my_var | mandatory }}

default will set a variable without value to a default value. Add the optional True to also set the variable if it has an empty string or a boolean False as its value 
{{ my_var | default(myvalue,True) }}

capitalize will capitalize a string

int will convert a variable to an integer

float converts a variable to a float

+ - / * perform basic calculations {{ ( vgsize | int) -1 }}

union creates a single list based on multiple input lists

random extracts a random element from a list 
{{ [a,b,c] | random }}

sort will sort a list 
{{ [4,8,2,5] | sort }}

password_hash generates a hashed password

quote used to put command output between quotes so that it is sanitized

vim assert_filter.yaml
---
- name: demonstrate filters
  hosts: localhost
  tasks:
  - name: manipulate a list and check
    assert:
      that:
      - "{{ [ 2, 3, 1, 2, 4, 2 ] | sort | unique | list }} is eq( [ 1, 2, 3, 4 ] )"
	  

vim password_hash.yaml
---
- name: create user with encrypted pass
  hosts: ansible2
  vars_prompt:
  - name: passw
    prompt: which password do you want to use
  vars:
    user: sharon
  tasks:
  - debug: 
      msg: "{{ '{{ passw }}' | password_hash('sha512','myrandomsalt') }}"
    register: mypass
  - debug:
      var: mypass
  - name: create the user
    user: 
      name: "{{ user }}"
      password: "{{ mypass.msg }}"


########################

Understanding the ipaddr filter

The ipaddr filter works on IP addresses to show specific IP address-related output

Before using, install the python3-netaddr as well as python3-dns package libraries

Arguments:
address: validates that input contains valid IP addresses
net: validates that input values are network ranges
host: ensures that IP addresses conform to CIDR prefix format
prefix: returns the network address prefix

vim network.yaml
---
- name: exploring network plugins and filters
  hosts: all
  vars:
    addresses:
    - 1.2.3.4/24
    - 10.0.0.0/8
    net_mask: "{{ ansible_default_ipv4.network }}/{{ ansible_default_ipv4.netmask }}"
  tasks:
  - name: print IP address
    debug:
      msg: the IP address is {{ ansible_facts['default_ipv4'] }}
  - name: show if this is a valid IP address
    debug:
      msg: "{{ ansible_facts['default_ipv4']['address'] | ipaddr }}"
  - name: ths happens if the variable does not contain a valid IP address
    debug:
      msg: "{{ ansible_facts['default_ipv4'] | ipaddr }}"
  - name: now lets check out the netmask
    debug:
      msg: "{{ net_mask | ipaddr('netmask') }}"
  - name: net is used to convert netmask to CIDR notation
    debug:
      msg: "{{ net_mask | ipaddr('net') }}"
  - name: host/prefix will filter out only valid host IP addresses and skip network addresses from a list in 1.1.1.1/24 format
    debug:
      msg: "{{ addresses | ipaddr('host/prefix') }}"
  - name: or size to show available size in this specific network
    debug:
      msg: "{{ ansible_facts['default_ipv4']['network'] | ipaddr('size') }}"
  - name: rewriting an IPv4 address to IPv6
    debug:
      msg: "{{ addresses | ipv4('ipv6') }}"
  - name: and how about converting IP addresses to hex format
    debug:
      msg: "{{ ansible_facts['default_ipv4']['address'] | ip4_hex }}"
  - name: or int format
    debug:
      msg: "{{ ansible_facts['default_ipv4']['address'] | ipaddr('int') }}"
  - name: an how about finding available IP addresses in a range
    debug:
      msg: "{{ '193.179.99.8/27' | ipaddr('range_usable') }}"



